<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <!-- <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"> -->
    <title>malloc47/page5/</title>
    
    <meta name="description" content="">
    <meta name="keywords" content="">
    <meta name="author" content="Jarrell Waggoner">
    <meta property="og:url" content="https://www.malloc47.com/page5/" />
    <meta property="og:title" content="malloc47" />
    <meta property="og:type" content="article" />
    
    <meta name="viewport" content="width=720">
    <link rel="preload" href="/font/Existence-Light-webfont.woff2" as="font" type="font/woff2" crossorigin>
    <link rel="preload" href="/font/Gudea-Regular-webfont.woff2" as="font" type="font/woff2" crossorigin>
    <link rel="preload" href="/font/Gudea-Italic-webfont.woff2" as="font" type="font/woff2" crossorigin>
    <link rel="preload" href="/font/Gudea-Bold-webfont.woff2" as="font" type="font/woff2" crossorigin>
    <link rel="preload" href="/font/Inconsolata-webfont.woff2" as="font" type="font/woff2" crossorigin>
    <link rel="stylesheet" href="/assets/style.css">
    <link id="day-css" rel="stylesheet" href="/assets/night.css" disabled>
    <link id="night-css" rel="stylesheet" href="/assets/day.css" disabled>
    <script src="/assets/main.js" type="text/javascript"></script>
  </head>
  <body>
    <div class="icons-left">
      <canvas id="miniclock" width="50" height="50" class="selectable"></canvas>
      <span id="toggle" class="transparent-light toggle selectable"></span>
    </div>
        <div class="icons">
      <a href="mailto:malloc47@gmail.com" class="transparent gmail"></a>
      <a href="https://www.github.com/malloc47" class="transparent github"></a>
    </div>

    <div id="container">
            <header id="main-header">
	<p>malloc(<span class="header-number"><a href="/">47</a></span>)</p>
	<p class="header-name">&mdash;<a href="https://www.twitter.com/malloc47">Jarrell Waggoner</a>&mdash;</p>
      </header>

            <nav>
      	<ul>
      	  <li><a href="/" title="Home">Home</a></li>
      	  <li><a href="/about" title="About">About</a></li>
      	  <li><a href="/music" title="Music">Music</a></li>
      	  <li><a href="/research" title="Research">Research</a></li>
      	  <li><a href="/talks" title="Talks">Talks</a></li>
      	  <li><a href="mailto:malloc47@gmail.com" title="Email">Contact</a></li>
      	</ul>
      </nav>

      <div id="contents" role="main">
        

<div class="content">
  <div class="content-wrap">
    <p class="date">2012 <span class="date-dark">00</span>02 <span class="date-dark">00</span>18 </p>
        <p class="social">
      <a href="https://www.facebook.com/sharer.php?u=https%3A%2F%2Fwww.malloc47.com%2Fpage5%2F&amp;t=page5%2F"
	 target="_blank"
	 rel="nofollow"
	 title="Share on Facebook">F</a>
      <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Fwww.malloc47.com%2Fpage5%2F&amp;text=page5%2F&amp;via=malloc47&amp;related=malloc47"
	 target="_blank"
	 title="Tweet"
	 rel="nofollow">T</a>
    </p>

    <header><a href="/import-links-into-google-plus-as-1s/">Import Links into Google Plus as +1s</a></header>
    <div class="content-body">
      <p>I've been accumulating helpful and interesting articles for a number
of years now. At first, they existed solely as starred articles in
Google Reader. Eventually, I migrated to
<a href="https://delicious.com/">Delicious</a>, and finally to
<a href="https://www.diigo.com">diigo</a>. While diigo has served me well, I
finally decided to consolidate services and begin using Google's +1
feature, as it is fairly ubiquitous and is associated with an account
I am already logged into (and appears nicely on my Google+ profile).</p>
<p>While Google's Takeout is very useful on the exporting front (a factor
I consciously consider before migrating to any system), I've never run
across a good way to import a list of links as +1s on my Google+
profile. So here's what I came up with last night:</p>
<pre><code class="bash">#!/bin/sh
echo &quot;&lt;html&gt;&lt;head&gt;&quot; &gt; page.html
echo &quot;&lt;script type=\&quot;text/javascript\&quot; src=\&quot;https://apis.google.com/js/plusone.js\&quot;&gt;&lt;/script&gt;&quot; &gt;&gt; page.html
echo &quot;&lt;/head&gt;&lt;body&gt;&quot; &gt;&gt; page.html
grep -o http[^\&quot;\)\']* $1 | xargs -I{} echo &quot;&lt;g:plusone href=\&quot;{}\&quot;&gt;&lt;/g:plusone&gt;&quot; &gt;&gt; page.html
echo &quot;&lt;/body&gt;&lt;/html&gt;&quot; &gt;&gt; page.html
</code></pre>
<p>Since diigo will happily let you export in a variety of formats, I
chose the csv file. My goal was simply to create a webpage with the
links and the +1 button next to each. The process of clicking the
buttons themselves could be automated, but I decided to manually click
on the buttons, since I wanted to vet the links I transferred. The
very simple (read: not iron-clad) regex (<code>http[^\&quot;\)\']*</code>) is used to
pull out the links. It looks for an instance of a string &quot;http&quot; and
then continues grabbing characters until it hits a quote. It should
work in a number of contexts, aside from just CSV files. <code>xargs</code>
kindly loops over all of these addresses and outputs each in HTML
form. The rest of the script just adds the usual HTML boilerplate, as
well as the +1 script necessary for the buttons to work.</p>
<p>One more wrinkle: the latest crop of browsers sandbox what javascript
is allowed to do to the local filesystem (and rightfully so), so you
will need to upload the generated page to a non-local path (or simply
copy and paste it into a website that will let you edit html
live). Once you do, just click on all the +1 buttons everywhere, and
your links will be +1'd accordingly.</p>
<p>Have a <a href="https://plus.google.com/u/0/113712188424853568731/plusones">look</a>.</p>

    </div>
  </div>
</div>

<div class="content">
  <div class="content-wrap">
    <p class="date">2012 <span class="date-dark">00</span>02 <span class="date-dark">00</span>11 </p>
        <p class="social">
      <a href="https://www.facebook.com/sharer.php?u=https%3A%2F%2Fwww.malloc47.com%2Fpage5%2F&amp;t=page5%2F"
	 target="_blank"
	 rel="nofollow"
	 title="Share on Facebook">F</a>
      <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Fwww.malloc47.com%2Fpage5%2F&amp;text=page5%2F&amp;via=malloc47&amp;related=malloc47"
	 target="_blank"
	 title="Tweet"
	 rel="nofollow">T</a>
    </p>

    <header><a href="/man-page-readability/">Man Page Readability</a></header>
    <div class="content-body">
      <p>Man pages are one of the staples of a healthy *nix diet, but having
grown up with them, it didn't occur to me until recently to wonder how
readable they really are. The de facto standard for readability
has--for better or worse--converged to the <a href="https://en.wikipedia.org/wiki/Flesch%E2%80%93Kincaid_readability_test">Flesch–Kincaid</a> test,
which (a particular variant) ranks readability as a &quot;grade level,&quot;
roughly corresponding to an American school grade. Getting a
readability score for a manpage is as simple as piping our man page to
the GNU <em>style</em> program (not installed on many distros, I discovered,
and typically available in the &quot;diction&quot; package).</p>
<pre><code>&gt; man /usr/share/man/man1/git.1.gz | style
readability grades:
        Kincaid: 7.0
        ARI: 4.4
        Coleman-Liau: 4.0
        ...
</code></pre>
<p>Notice that man can read in the (tarzipped) man source file (typically
located in <code>/usr/share/man/man?</code> folders) rather than having to type
the executable name.</p>
<p>Since we're only concerned with the Kincaid score, we can apply a
smattering of grep+awk to extract it.</p>
<pre><code>man /usr/share/man/man1/git.1.gz | style | grep Kincaid | awk '{print $2'}
</code></pre>
<p>And finally, looping over all the installed man pages (+sed to trim
out short sentences, headers, etc.) gives us one big file, from which
we can get readability statistics.</p>
<pre><code>for i in `ls -d -1 /usr/share/man/man?/*` ; do echo -n &quot;$i &quot; ; man $i | tr '\n' ' ' | sed 's/\./\.\n/g' | sed -e 's/^[ \t]*//' | sed '/.\{3\}/!d' | grep Kincaid | awk '{print $2}' ; done &gt; ~/flesch-kincaid
</code></pre>
<p>More awk magic will give us an average and standard deviation.</p>
<pre><code>&gt; awk '{avg+=$2} END {print avg/NR}' ~/flesch-kincaid
9.08134
&gt; awk '{sum+=$2; sumsq+=$2*$2} END {print sqrt(sumsq/NR - (sum/NR)**2)}' ~/flesch-kincaid
10.3857
</code></pre>
<p>Perhaps surprisingly, the average readability of the man pages on my
machine is below the college level. More unexpectedly, the standard
deviation is very high, indicating that there's a wide range of
readability from one man page to another. The page with the most
absurdly large readability score</p>
<pre><code>grep `awk '$2&gt;m{m=$2}END{print m}' ~/flesch-kincaid` ~/flesch-kincaid
</code></pre>
<p>consist almost entirely of code and API documentation.</p>
<p>Of course, this does not take into account a myriad of confounding
factors: some non-English language pages crept into the list, which
kick out bogus scores by the Flesch–Kincaid metric, man pages have
non-standard formatting (e.g. command switches) which aren't
considered in the metric, etc. But knowing the general (or at least
average) education level required to comprehend man pages is worth
considering as more mainstream distributions bring with them an influx
of younger and less experienced users.</p>

    </div>
  </div>
</div>

<div class="content">
  <div class="content-wrap">
    <p class="date">2011 <span class="date-dark">00</span>05 <span class="date-dark">00</span>18 </p>
        <p class="social">
      <a href="https://www.facebook.com/sharer.php?u=https%3A%2F%2Fwww.malloc47.com%2Fpage5%2F&amp;t=page5%2F"
	 target="_blank"
	 rel="nofollow"
	 title="Share on Facebook">F</a>
      <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Fwww.malloc47.com%2Fpage5%2F&amp;text=page5%2F&amp;via=malloc47&amp;related=malloc47"
	 target="_blank"
	 title="Tweet"
	 rel="nofollow">T</a>
    </p>

    <header><a href="/vim-to-emacs/">vim -&gt; emacs</a></header>
    <div class="content-body">
      <p>After having grown up in the terminal with vim at my side, I've been transitioning to back to emacs. There's no shortage of guides for making the leap, but there's a number of features in vim that operate very differently in emacs, or do not map cleanly to a single feature. There's nothing like not knowing how to get that <em>one</em> feature you rely on when making the vim-&gt;emacs leap to make you want to run back to familiar territory. Here's a few of the discoveries I've made along the way.</p>
<pre><code>dd -&gt; C-Shift-Backspace
</code></pre>
<p><strong>C-k</strong> is more often cited as the analog for <strong>dd</strong> (and it is indeed more flexible in many situations), but as far as raw functionality is concerned, sometimes you just want the current line to go away, regardless of where the cursor is. Unfortunately, the** C-Shift-Backspace** keybinding may not be triggered when you're running emacs in a screen or xterm (emacs -nw), but for the majority of standard emacs use, it's a feature-compatible substitute.</p>
<pre><code>% -&gt; C-M-n, C-M-p
</code></pre>
<p>Traversing pairs of grouping characters (e.g. (), [], {}, etc.) with vim's % key is invaluable, but emacs not only replicates this feature, but adds a few new bits of functionality too. In general <strong>C-n</strong> and <strong>C-p</strong> will traverse to the next or previous line, respectively, but <strong>C-M-n</strong> and <strong>C-M-p</strong> will traverse forward or backward over the current <em>list</em>. Since emacs has a major mode related to most languages you could find yourself working in (and if not, it's not difficult to find or make one) that will do a rudimentary parse of the code into proper tokens, <strong>C-M-n</strong> and <strong>C-M-p</strong> can intelligently jump to the beginning or end of parenthetical structures, words, or blocks with equal effectiveness. As a bonus, you also get <strong>C-M-d</strong> (if your window manager hasn't stolen that keybinding) and <strong>C-M-u</strong> that go down or up (respectively) in the current structure---i.e., <strong>C-M-d</strong> will place the cursor inside the parenthetical statement, ready to iterate over the items inside the parentheses with <strong>C-M-n</strong>, while <strong>C-M-u</strong> will place the cursor at the beginning of the parenthesis or block structure enclosing the cursor. Check the major mode you are in for even more context-sensitive commands (e.g., <strong>M-a</strong> and <strong>M-e</strong> to go the beginning or ending of a statement in the C++ major mode). Another instance where it <em>seems</em> like emacs adds overhead to the preciously minimalistic vim keybindings, but having two keys instead of one adds immeasurable navigational flexibility.</p>
<pre><code>f, F, t, T -&gt; C-s, C-r
</code></pre>
<p>This may not be immediately intuitive, but the best mapping for vim's nifty &quot;forward (or backward) to character&quot; feature is emacs's standard search function. While, yes, the concession is that it requires three keystrokes (you must press enter after searching in emacs to position the cursor) instead of one, you get the same functionality, with the added benefit that you can search more than one character easily, and you don't have to retype the character you want to jump to, as you would in vim.</p>
<pre><code>[n]gg, :[n] -&gt; M-g g
</code></pre>
<p>Though emacs integrates so well into most REPLs that you don't often need to jump to specific line numbers manually, it's still trivial to hop to specific line numbers with ease. Again, you're sacrificing more keystrokes but, as with everything in emacs, you can remap anything you use often. Alternately, consider using the faster <strong>C-[n] M-g g</strong> variant to prepend the line number instead of having to specify it (and hit enter) in the mini-buffer.</p>
<pre><code>&quot;[register]p -&gt; C-y M-y
</code></pre>
<p>The kill ring in emacs isn't remotely complex, so it's hardly worth mentioning except that it varies greatly from vim's model of using registers to store yanked text. Instead of having to specify a register, as you do in vim, you simply paste whatever text happens to be in the ring into your document/code with <strong>C-y</strong>, then loop through the various yanks with <strong>M-y</strong>. Coming from a vim world, where every yank requires a register that contains only one snippet of text, the value of having yanks (or kills) you can scroll through (in the exact context you wish to paste them) is quite clear (and can actually result in fewer keystrokes for complicated yanks). As a bonus, only having to use <strong>C-w</strong> or <strong>M-w</strong> to yank text requires fewer keystrokes than having to use <strong>&quot;[reg]y</strong> in vim too.</p>
<pre><code>q[register] ... q -&gt; C-x ( ... C-x ) M-x name-last-kbd-macro [name]
</code></pre>
<p>The only surface difference between vim and emacs for keyboard macros is that vim assigns keyboard macros to a register by default, but emacs requires <strong>M-x name-last-kbd-macro</strong> to cache more than one macro at a time. The difference becomes more stark once you explore multiple macros, as you can apply a named keyboard macro by using <strong>M-x [name]</strong>, since emacs saves the keyboard macro as a standard emacs command. As a bonus you can use the <strong>M-x insert-kbd-macro</strong> to save the macro to your <em>.emacs</em> file for future use.</p>
<pre><code>u, C-r -&gt; C-/
</code></pre>
<p>This is another emacs feature that's very simple to understand, but where vim logic may trip you up. Most vim-&gt;emacs guides will clue you in that vim's <strong>u</strong> maps to emacs <strong>C-/</strong> (<strong>C-_</strong> or <strong>C-x u</strong>, but those are more of a hassle), which is indeed correct. But the underlying &quot;redo&quot; logic is a bit different. Instead of vim's separate <strong>C-r</strong> redo command, emacs lets you &quot;undo your undos&quot; (again, think yank ring). So after a series of consecutive **C-/**s, all you need do is interrupt the sequence with a command that does not produce any undo history (I typically use a movement command like <strong>C-f</strong>), and then use <strong>C-/</strong> again, which will then, essentially, have become a &quot;redo&quot; command. This will become second nature quickly, but it's a very different model from the inferior method used by vim (and a large number of other editors).</p>
<pre><code>: -&gt; M-:, M-x
</code></pre>
<p>Only thing worth mentioning here is the difference between executing direct elisp code (<strong>M-:</strong>) and emacs commands (<strong>M-x</strong>), which is not a distinction that vim has to make.</p>
<pre><code>:tabn, gf -&gt; C-x b
</code></pre>
<p>Vim actually does allow for &quot;hidden&quot; buffers, so it can operate in a very emacsish way, if desired, but it a rarely-used feature; one that emacs adopts by default. Emacs doesn't have &quot;tabs&quot; to switch between, per se, but the way it handles buffers is vastly more powerful than any tab or hidden buffer in vim, minus the &quot;tab&quot; aesthetic (and ido-mode or <strong>C-x C-b</strong> is more than capable of providing a list if that is what is needed).</p>
<pre><code>Screen Line Movement -&gt; Logical Line Movement
</code></pre>
<p>Emacs's <strong>C-n</strong> and <strong>C-p</strong> move over screen lines (the line breaks you see on the screen) by default, while vim's <strong>j</strong>,<strong>k</strong> moves over logical lines (line breaks that are actually in the file). While vim's logical line movement can cause problems with long lines (you have to use <strong>gj</strong> and <strong>gk</strong> to switch over to screen lines), you can switch emacs to logical line movement, if you prefer it, with</p>
<pre><code>(setp line-move-visual nil)
</code></pre>
<p>which can be easily entered with <strong>M-:</strong> in emacs to try it out, or added to your <code>.emacs</code> file to save the setting.</p>

    </div>
  </div>
</div>


<nav id="pagination">
  
  <a class="left" href="/page4/">&#8826; Newer</a>
  
  
</nav>


      </div>
            <footer>
	<div class="icons">
	  <a href="/rss.xml" class="transparent rss"></a>
	</div>
	<div class="footer-padding">This site is licensed under <a rel="license" href="https://creativecommons.org/licenses/by/3.0/">Creative Commons Attribution 3.0</a>.</div>
      </footer>

      </div>
  </body>
</html>
